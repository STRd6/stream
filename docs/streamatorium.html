<!DOCTYPE html>

<html>
<head>
  <title>streamatorium</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="streamatorium">Streamatorium</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="introduction">Introduction</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The Streamatorium is an experiment in applying functional programming and Unix
principles to the web.</p>
<p>Processes may look something like these:</p>
<p>Print out even numbers to the console.</p>
<blockquote>
<pre><code>100.times filter(even) STDOUT</code></pre>
</blockquote>
<p>Get popular repos from a json data source and display them one at a time to the
console.</p>
<blockquote>
<pre><code>popular = (repo) -&gt; repo.watchers &gt; 100

json(&quot;https://api.github.com/repos/&quot;) each filter(popular) STDOUT</code></pre>
</blockquote>
<p>Atoms are any object. Atoms form streams by flowing through pipes. Atoms
originate in sources and end up in sinks.</p>
<p>Example atoms:</p>
<blockquote>
<pre><code>0, 1, &quot;&quot;, true, false, &quot;heyyy&quot;, 954, 
{}, {name: &quot;flambo&quot;}, [{...}, ...]</code></pre>
</blockquote>
<h2 id="sinks">Sinks</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>A sink is a function that accepts an atom.</p>
<p><code>STDOUT</code> logs any atom to the console</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">STDOUT</span></span> = (atom) -&gt; 
  console.log atom</code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The <code>NULL</code> sink eats any atom passed to it and does nothing</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">NULL</span></span> = (atom) -&gt;</code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A source is a function that takes a sink as an argument.</p>
<blockquote>
<pre><code>source = (sink) -&gt;
  ...</code></pre>
</blockquote>
<h2 id="pipes">Pipes</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>A pipe is a function that takes a sink and returns a sink. A pipe is both a
source and a sink.</p>
<p>A pipeline connects sources to sinks through pipes.</p>
<blockquote>
<pre><code>source pipe0 pipe1 pipe2 sink</code></pre>
</blockquote>
<p>This works due to function composition:</p>
<blockquote>
<pre><code>source(pipe0(pipe1(pipe2(sink))))</code></pre>
</blockquote>
<p>Pass items through to output unchanged. More useful as a demonstration than
an actual pipe.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">identity</span></span> = (output) -&gt;
  (atom) -&gt;
    output atom</code></pre>
</div>
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
countTo(10) identity STDOUT</code></pre>
</blockquote>
<hr>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Output atoms asynchrounously instead of immediately.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">defer</span></span> = (output) -&gt;
  (atom) -&gt;
    setTimeout output, <span class="number">0</span>, atom</code></pre>
</div>
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>each</code> splats arrays into individual items. Non-arrays are passed through as is.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">each</span></span> = (output) -&gt;
  (arrayOrItem) -&gt;
    [].concat(arrayOrItem).forEach (item) -&gt;
      output item</code></pre>
</div>
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
[1, 2, 3, 4, 5].tap T each STDOUT</code></pre>
</blockquote>
<hr>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Get JSON data from input urls then pass it along.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">getJSON</span></span> = (output) -&gt;
  (url) -&gt;
    $.getJSON(url).<span class="keyword">then</span> output</code></pre>
</div>
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
&quot;https://api.github.com/users/STRd6&quot;.tap getJSON prettyPrint STDOUT</code></pre>
</blockquote>
<hr>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><code>split</code> is a generalized T. When contsructed with a list of sinks it returns
a sink that outputs to all of the sinks it was constructed with.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">split</span></span> = (outputs...) -&gt;
  (atom) -&gt;
    outputs.forEach (output) -&gt;
      output atom</code></pre>
</div>
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2 id="pipe-generators">Pipe Generators</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>A pipe generator is a function that returns a pipe.</p>
<p>Similar to unix tee, splits a stream.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">tee</span></span> = (sink) -&gt;
  (output) -&gt;
    split sink, output</code></pre>
</div>
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Example of <code>tee</code> implemented wthout <code>split</code></p>
<blockquote>
<pre><code>tee = (sink) -&gt;     # Generator
  (output) -&gt;       # Pipe
    (atom) -&gt;       # Sink
      sink atom
      output atom</code></pre>
</blockquote>
<p><code>T</code> is a pipe that will mirror its atoms to the console. It is useful for
inspecting the flow at any point in the pipeline.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">T = tee(STDOUT)</code></pre>
</div>
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <blockquote>
<pre><code>source T pipe0 T pipe1 STDOUT</code></pre>
</blockquote>
<h2 id="maps">Maps</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Generate a pipe that transforms atoms by applying the given transformation
function to each atom as it passes through.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">map</span></span> = (fn) -&gt;
  (output) -&gt;
    (atom) -&gt;
      output fn(atom)</code></pre>
</div>
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><code>pluck</code> selects an attribute from an atom and passes that attribute on.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">pluck</span></span> = (name) -&gt; 
  (output) -&gt;
    (atom) -&gt;
      output atom[name]</code></pre>
</div>
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
{name: &quot;Duder&quot;}.tap pluck(&quot;name&quot;) STDOUT</code></pre>
</blockquote>
<p><code>invoke</code> generates a pipe that invokes the named function with the given 
arguments on each item passing through then passes the result on to the sink it
is connected to.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">invoke</span></span> = (name, args...) -&gt;
  (output) -&gt;
    (atom) -&gt;
      output atom[name](args...)</code></pre>
</div>
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
&quot;Welcome to the Streamatorium&quot;.tap invoke(&quot;split&quot;, &quot;&quot;) T each STDOUT</code></pre>
</blockquote>
<hr>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h2 id="filters">Filters</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Generate a pipe that only allows certain atoms to pass through. <code>filter</code> applies
the given indicator function and only passes through atoms for which it returns
true.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">filter</span></span> = (fn) -&gt;
  (output) -&gt;
    (atom) -&gt;
      output atom <span class="keyword">if</span> fn(atom)</code></pre>
</div>
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The <code>soak</code> pipe filters out <code>null</code> and <code>undefined</code> atoms.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">soak = filter (atom) -&gt; atom?</code></pre>
</div>
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
even = (x) -&gt; x % 2 is 0

countTo(25) filter(even) STDOUT</code></pre>
</blockquote>
<h2 id="stateful-pipes">Stateful Pipes</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>toggle</code> is a switch. Whenever it receives an input it will ouput either true or
false and switch its state to output the opposite value the next input it
receives. It doesn&#39;t matter what atom it receives.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">toggle</span></span> = (output) -&gt;
  value = <span class="literal">true</span>
  (atom) -&gt;
    output value
    value = !value</code></pre>
</div>
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <blockquote>
<pre><code>#! pipe
countTo(10) toggle STDOUT</code></pre>
</blockquote>
<p>Count number of atoms that flowed through, outputting the total count each time
and atom is received.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">counter</span></span> = (output) -&gt;
  value = <span class="number">0</span>
  (atom) -&gt;
    output value += <span class="number">1</span></code></pre>
</div>
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Sum the atoms that flow through and output the current total each time an atom
is received.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">accumulator</span></span> = (output) -&gt;
  value = <span class="number">0</span>
  (atom) -&gt;
    output value += atom</code></pre>
</div>
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Aggregate a stream of individual characters separated by whitespace into a stream
of word strings.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">tokenizer</span></span> = (output) -&gt;
  word = <span class="string">""</span>

  (character) -&gt;
    <span class="keyword">if</span> character.match <span class="regexp">/\s/</span>
      <span class="keyword">if</span> word
        output word

        word = <span class="string">""</span>
    <span class="keyword">else</span>
      word += character</code></pre>
</div>
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Connect the &quot;end&quot; of one pipeline to the begining of a new one.</p>
<p>TODO: Explore this further, currently seems like a pain to hold a reference
to a sink and carry it over as a source. Maybe if the constructor took names
to refer to connectors so we could use them without carrying the instances
ourselves, ex:</p>
<blockquote>
<pre><code>source pipe0 pipe1 TO(&quot;A&quot;)
FROM(&quot;A&quot;) pipe2 pipe3 STDOUT</code></pre>
</blockquote>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">connector</span></span> = -&gt;
  atoms = []
  output = <span class="literal">null</span>

  <span class="function"><span class="title">flush</span></span> = -&gt;
    <span class="keyword">if</span> output
      <span class="keyword">while</span> atoms.length
        output atoms.shift()

  <span class="function"><span class="title">collector</span></span> = (atom) -&gt;
    atoms.push atom

    flush()

  collector.<span class="function"><span class="title">source</span></span> = (sink) -&gt;
    output = sink

    flush()

  <span class="keyword">return</span> collector</code></pre>
</div>
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h2 id="clocks">Clocks</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Emit an atom periodically. The <code>clock</code> constructor returns a source.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">clock</span></span> = (t) -&gt;
  (output) -&gt;
    setInterval -&gt;
      output <span class="number">1</span>
    , t * <span class="number">1000</span></code></pre>
</div>
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h2 id="controls">Controls</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>TODO: Transistors and stuff.</p>
<h2 id="gates">Gates</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Attempt at a buffer that collects input and releases them based on a
control/signal input.</p>
<p><code>ctrl</code> is a source</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">gate</span></span> = (ctrl) -&gt;
  (output) -&gt;
    buffer = []

    ctrl -&gt;
      output buffer.shift()

    (atom) -&gt;
      buffer.push atom</code></pre>
</div>
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Maintain most recent value and emit it on CTRL.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">latch</span></span> = (ctrl) -&gt;
  (output) -&gt;
    value = <span class="literal">undefined</span>

    ctrl -&gt;
      output value

    (atom) -&gt;
      value = atom</code></pre>
</div>
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h2 id="examples">Examples</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>JSON to Template</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">jsonExample</span></span> = -&gt;
  rows = Observable([])
  headers = Observable([])

  rows.observe (newRows) -&gt;
    <span class="keyword">if</span> firstRow = newRows.first()
      headers Object.keys firstRow

  template = require(<span class="string">'./templates/table'</span>)(
    rows: rows
    headers: headers
  )

  pipeline = T getJSON T rows
  pipeline(<span class="string">"https://api.github.com/repositories"</span>)
  $(<span class="string">"body"</span>).append(template)

<span class="function"><span class="title">clockExample</span></span> = -&gt;
  clock(<span class="number">1</span>) STDOUT

<span class="function"><span class="title">gateExample</span></span> = -&gt;
  <span class="number">25.</span>times gate(clock(<span class="number">0.25</span>)) soak defer T NULL

module.exports = Streamatorium =
  each: each
  filter: filter
  getJSON: getJSON
  identity: identity
  invoke: invoke
  map: map
  pluck: pluck
  pollute: -&gt;
    Object.keys(Streamatorium).forEach (name) -&gt;
      <span class="keyword">unless</span> name <span class="keyword">is</span> <span class="string">"pollute"</span>
        global[name] = Streamatorium[name]
  T: T
  tee: tee
  toggle: toggle</code></pre>
</div>
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h2 id="live-examples">Live Examples</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><code>pipe</code> examples provide the pipe functions and dislpay all atoms received in
STDOUT on the righthand side.</p>
<blockquote>
<pre><code>#! setup
require(&quot;/interactive_runtime&quot;)</code></pre>
</blockquote>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script src="http://strd6.github.io/require/v0.2.1.js"></script>
<script src="http://strd6.github.io/interactive/v0.8.0.js"></script>
<script>
  (function(pkg) {
    // Expose a require for our package so scripts can access our modules
    window.require = Require.generateFor(pkg);
  })({
  "version": "0.1.0",
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "stream\n======\n\nLearning about streams\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "entryPoint: \"streamatorium\"\nversion: \"0.1.0\"\nremoteDependencies: [\n  \"http://strd6.github.io/require/v0.2.1.js\"\n]\n",
      "type": "blob"
    },
    "sicp_stream.coffee.md": {
      "path": "sicp_stream.coffee.md",
      "mode": "100644",
      "content": "Stream\n======\n\nHere I will learn about streams using interactive models.\n\nConstruct a stream\n\n    Stream = (first, rest=->emptyStream) ->\n      self =\n        first: ->\n          first\n        rest: rest\n\nGet an element from a stream at position `n`\n\n        get: (n) ->\n          if n is 0\n            self.first()\n          else\n            rest().get(n - 1)\n\nInvoke a function for each item in a stream.\n\n        each: (fn) ->\n          fn(self.first())\n          rest().each(fn)\n\n          self\n\nTransform a stream\n\n        map: (fn) ->\n          Stream(\n            fn(self.first()),\n            -> rest().map(fn)\n          )\n\nA distinguishable object representing the empty stream.\n\n    emptyStream =\n      map: ->\n        emptyStream\n      each: ->\n        emptyStream\n      get: ->\n\nExport\n\n    module.exports = Stream\n\nNotes\n-----\n\nPassing in the second argument as a function to be evaluated later is a little\ntough on the user interface. The solution may be to provide helpers or higher\nlevels of abstraction so that we don't have to mess with streams directly,\njust create them from various other sources like text, lists, ajax requests,\ngenerator functions, etc. and be able to pipe them together in a signal flow\nstyle.\n\nAnother thing to explore is promises/deferreds and using those as our piping\ninterface.\n\nThe primary use case in my mind is something like:\n\n>\n>     +----------+                        +-----+                    +------+                   +--------+                        +------+\n>     |FileReader| -> Character Stream -> |Lexer| -> Token Stream -> |Parser| -> Node Stream -> |Compiler| -> Character Stream -> |STDOUT|\n>     +----------+                        +-----+                    +------+                   +--------+                        +------+\n>          |                                 |                          |                           |\n>          v                                 v                          v                           v                             +------+\n>          +---------------------------------+--------------------------+---------------------------+------------------------- -> |STDERR|\n>                                                                                                                                 +------+\n\nWhich could be connected something like:\n\n>     errors STDERR\n>\n>     reader lexer parser compiler STDOUT\n\nResources\n---------\n\nhttp://mitpress.mit.edu/sicp/full-text/sicp/book/node70.html\n",
      "type": "blob"
    },
    "streamatorium.coffee.md": {
      "path": "streamatorium.coffee.md",
      "mode": "100644",
      "content": "Streamatorium\n=============\n\nIntroduction\n------------\n\nThe Streamatorium is an experiment in applying functional programming and Unix\nprinciples to the web.\n\nProcesses may look something like these:\n\nPrint out even numbers to the console.\n\n>     100.times filter(even) STDOUT\n\nGet popular repos from a json data source and display them one at a time to the\nconsole.\n\n>     popular = (repo) -> repo.watchers > 100\n>\n>     json(\"https://api.github.com/repos/\") each filter(popular) STDOUT\n\n\nAtoms are any object. Atoms form streams by flowing through pipes. Atoms\noriginate in sources and end up in sinks.\n\nExample atoms:\n\n>     0, 1, \"\", true, false, \"heyyy\", 954, \n>     {}, {name: \"flambo\"}, [{...}, ...]\n\nSinks\n-----\n\nA sink is a function that accepts an atom.\n\n`STDOUT` logs any atom to the console\n\n    STDOUT = (atom) -> \n      console.log atom\n\nThe `NULL` sink eats any atom passed to it and does nothing\n\n    NULL = (atom) ->\n\nA source is a function that takes a sink as an argument.\n\n>     source = (sink) ->\n>       ...\n\nPipes\n-----\n\nA pipe is a function that takes a sink and returns a sink. A pipe is both a\nsource and a sink.\n\nA pipeline connects sources to sinks through pipes.\n\n>     source pipe0 pipe1 pipe2 sink\n\nThis works due to function composition:\n\n>     source(pipe0(pipe1(pipe2(sink))))\n\nPass items through to output unchanged. More useful as a demonstration than\nan actual pipe.\n\n    identity = (output) ->\n      (atom) ->\n        output atom\n\n>     #! pipe\n>     countTo(10) identity STDOUT\n\n----\n\nOutput atoms asynchrounously instead of immediately.\n\n    defer = (output) ->\n      (atom) ->\n        setTimeout output, 0, atom\n\n`each` splats arrays into individual items. Non-arrays are passed through as is.\n\n    each = (output) ->\n      (arrayOrItem) ->\n        [].concat(arrayOrItem).forEach (item) ->\n          output item\n\n>     #! pipe\n>     [1, 2, 3, 4, 5].tap T each STDOUT\n\n----\n\nGet JSON data from input urls then pass it along.\n\n    getJSON = (output) ->\n      (url) ->\n        $.getJSON(url).then output\n    \n>     #! pipe\n>     \"https://api.github.com/users/STRd6\".tap getJSON prettyPrint STDOUT\n\n----\n\n`split` is a generalized T. When contsructed with a list of sinks it returns\na sink that outputs to all of the sinks it was constructed with.\n\n    split = (outputs...) ->\n      (atom) ->\n        outputs.forEach (output) ->\n          output atom\n\nPipe Generators\n---------------\n\nA pipe generator is a function that returns a pipe.\n\nSimilar to unix tee, splits a stream.\n\n    tee = (sink) ->\n      (output) ->\n        split sink, output\n\nExample of `tee` implemented wthout `split`\n\n>     tee = (sink) ->     # Generator\n>       (output) ->       # Pipe\n>         (atom) ->       # Sink\n>           sink atom\n>           output atom\n\n`T` is a pipe that will mirror its atoms to the console. It is useful for\ninspecting the flow at any point in the pipeline.\n\n    T = tee(STDOUT)\n\n>     source T pipe0 T pipe1 STDOUT\n\nMaps\n----\n\nGenerate a pipe that transforms atoms by applying the given transformation\nfunction to each atom as it passes through.\n\n    map = (fn) ->\n      (output) ->\n        (atom) ->\n          output fn(atom)\n\n`pluck` selects an attribute from an atom and passes that attribute on.\n\n    pluck = (name) -> \n      (output) ->\n        (atom) ->\n          output atom[name]\n\n>     #! pipe\n>     {name: \"Duder\"}.tap pluck(\"name\") STDOUT\n\n`invoke` generates a pipe that invokes the named function with the given \narguments on each item passing through then passes the result on to the sink it\nis connected to.\n\n    invoke = (name, args...) ->\n      (output) ->\n        (atom) ->\n          output atom[name](args...)\n\n>     #! pipe\n>     \"Welcome to the Streamatorium\".tap invoke(\"split\", \"\") T each STDOUT\n\n----\n\nFilters\n-------\n\nGenerate a pipe that only allows certain atoms to pass through. `filter` applies\nthe given indicator function and only passes through atoms for which it returns\ntrue.\n\n    filter = (fn) ->\n      (output) ->\n        (atom) ->\n          output atom if fn(atom)\n\nThe `soak` pipe filters out `null` and `undefined` atoms.\n\n    soak = filter (atom) -> atom?\n  \n>     #! pipe\n>     even = (x) -> x % 2 is 0\n>\n>     countTo(25) filter(even) STDOUT\n\nStateful Pipes\n--------------\n\n`toggle` is a switch. Whenever it receives an input it will ouput either true or\nfalse and switch its state to output the opposite value the next input it\nreceives. It doesn't matter what atom it receives.\n\n    toggle = (output) ->\n      value = true\n      (atom) ->\n        output value\n        value = !value\n\n>     #! pipe\n>     countTo(10) toggle STDOUT\n\nCount number of atoms that flowed through, outputting the total count each time\nand atom is received.\n\n    counter = (output) ->\n      value = 0\n      (atom) ->\n        output value += 1\n\nSum the atoms that flow through and output the current total each time an atom\nis received.\n\n    accumulator = (output) ->\n      value = 0\n      (atom) ->\n        output value += atom\n\nAggregate a stream of individual characters separated by whitespace into a stream\nof word strings.\n\n    tokenizer = (output) ->\n      word = \"\"\n\n      (character) ->\n        if character.match /\\s/\n          if word\n            output word\n\n            word = \"\"\n        else\n          word += character\n\nConnect the \"end\" of one pipeline to the begining of a new one.\n\nTODO: Explore this further, currently seems like a pain to hold a reference\nto a sink and carry it over as a source. Maybe if the constructor took names\nto refer to connectors so we could use them without carrying the instances\nourselves, ex:\n>     source pipe0 pipe1 TO(\"A\")\n>     FROM(\"A\") pipe2 pipe3 STDOUT\n\n    connector = ->\n      atoms = []\n      output = null\n\n      flush = ->\n        if output\n          while atoms.length\n            output atoms.shift()\n\n      collector = (atom) ->\n        atoms.push atom\n\n        flush()\n\n      collector.source = (sink) ->\n        output = sink\n\n        flush()\n\n      return collector\n\nClocks\n------\n\nEmit an atom periodically. The `clock` constructor returns a source.\n\n    clock = (t) ->\n      (output) ->\n        setInterval ->\n          output 1\n        , t * 1000\n\nControls\n--------\n\nTODO: Transistors and stuff.\n\nGates\n-----\n\nAttempt at a buffer that collects input and releases them based on a\ncontrol/signal input.\n\n`ctrl` is a source\n\n    gate = (ctrl) ->\n      (output) ->\n        buffer = []\n\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n\nMaintain most recent value and emit it on CTRL.\n\n    latch = (ctrl) ->\n      (output) ->\n        value = undefined\n\n        ctrl ->\n          output value\n\n        (atom) ->\n          value = atom\n\nExamples\n-------\n\nJSON to Template\n\n    jsonExample = ->\n      rows = Observable([])\n      headers = Observable([])\n\n      rows.observe (newRows) ->\n        if firstRow = newRows.first()\n          headers Object.keys firstRow\n\n      template = require('./templates/table')(\n        rows: rows\n        headers: headers\n      )\n\n      pipeline = T getJSON T rows\n      pipeline(\"https://api.github.com/repositories\")\n      $(\"body\").append(template)\n\n    clockExample = ->\n      clock(1) STDOUT\n\n    gateExample = ->\n      25.times gate(clock(0.25)) soak defer T NULL\n\n    module.exports = Streamatorium =\n      each: each\n      filter: filter\n      getJSON: getJSON\n      identity: identity\n      invoke: invoke\n      map: map\n      pluck: pluck\n      pollute: ->\n        Object.keys(Streamatorium).forEach (name) ->\n          unless name is \"pollute\"\n            global[name] = Streamatorium[name]\n      T: T\n      tee: tee\n      toggle: toggle\n\nLive Examples\n-------------\n\n`pipe` examples provide the pipe functions and dislpay all atoms received in\nSTDOUT on the righthand side.\n\n>     #! setup\n>     require(\"/interactive_runtime\")\n",
      "type": "blob"
    },
    "templates/table.haml.md": {
      "path": "templates/table.haml.md",
      "mode": "100644",
      "content": "A table template to render rows from stuff!\n\n    %table\n      %thead\n        %tr\n          - each @headers, (header) ->\n            %th= header\n      %tbody\n        - each @rows, (row) ->\n          %tr\n            - Object.keys(row).each (name) ->\n              %td= row[name]\n",
      "type": "blob"
    },
    "test/stream.coffee.md": {
      "path": "test/stream.coffee.md",
      "mode": "100644",
      "content": "    require \"../streamatorium\"\n",
      "type": "blob"
    },
    "notes.coffee.md": {
      "path": "notes.coffee.md",
      "mode": "100644",
      "content": "Notes\n=====\n\nWhen nesting the functions avoid leaky closures:\n\n    # GOOD, can reuse the \"same\" gate in multiple streams no problem\n    gate = (ctrl) ->\n      (output) ->\n        buffer = []\n\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n\n    # BAD, gate will get weird if used in multiple streams\n    gate = (ctrl) ->\n      buffer = []\n\n      (output) ->\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n",
      "type": "blob"
    },
    "util.coffee.md": {
      "path": "util.coffee.md",
      "mode": "100644",
      "content": "Utility Functions\n-----------------\n\n    module.exports =\n\nEvaluate a program with a given environment object.\n\nThe values of the environment are mapped to local variables with names equal to\nthe keys.\n\nThe given program is then run with that environment and optionally a context for\n`this`.\n\n      executeWithContext: (program, environment, context) ->\n        args = Object.keys(environment)\n\n        values = args.map (name) -> \n          environment[name]\n\n        Function(args..., program).apply(context, values)\n",
      "type": "blob"
    },
    "environment_helpers.coffee.md": {
      "path": "environment_helpers.coffee.md",
      "mode": "100644",
      "content": "Environment Helpers\n-------------------\n\nSome helpers that we add to the global environment so we can use our streams to\ntheir fullest.\n\nAdding `Object#tap` so it's easier to put any object into the beginnig of a\nstream.\n\n    unless Object.prototype.tap\n      Object.defineProperty Object.prototype, \"tap\",\n        enumerable: false\n        configurable: false\n        writable: false\n        value: (fn) ->\n          fn(this)\n\n          return this\n\n`countTo` generates a source that emits sequence of values from [0, n).\n\n    global.countTo = (n) ->\n      (output) ->\n        i = 0\n        while i < n\n          output(i)\n          i += 1\n\n`prettyPrint` \n\n    global.prettyPrint = (output) ->\n      (atom) ->\n        output JSON.stringify(atom, null, 2)\n",
      "type": "blob"
    },
    "interactive_runtime.coffee.md": {
      "path": "interactive_runtime.coffee.md",
      "mode": "100644",
      "content": "Interactive Runtime\n-------------------\n\nRegister our interactive documentation runtime components.\n\n    require(\"/environment_helpers\")\n    require(\"/streamatorium\").pollute()\n    {executeWithContext} = require(\"/util\")\n\n    Interactive.register \"pipe\", ({source, runtimeElement}) ->\n      program = CoffeeScript.compile(source)\n\n      outputElement = document.createElement \"pre\"\n      runtimeElement.empty().append outputElement\n\n      STDOUT = (atom) ->\n        outputElement.textContent += \"#{atom}\\n\"\n\n      executeWithContext program,\n        T: tee(STDOUT)\n        STDOUT: STDOUT\n        NULL: ->\n",
      "type": "blob"
    }
  },
  "distribution": {
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"entryPoint\":\"streamatorium\",\"version\":\"0.1.0\",\"remoteDependencies\":[\"http://strd6.github.io/require/v0.2.1.js\"]};",
      "type": "blob"
    },
    "sicp_stream": {
      "path": "sicp_stream",
      "content": "(function() {\n  var Stream, emptyStream;\n\n  Stream = function(first, rest) {\n    var self;\n    if (rest == null) {\n      rest = function() {\n        return emptyStream;\n      };\n    }\n    return self = {\n      first: function() {\n        return first;\n      },\n      rest: rest,\n      get: function(n) {\n        if (n === 0) {\n          return self.first();\n        } else {\n          return rest().get(n - 1);\n        }\n      },\n      each: function(fn) {\n        fn(self.first());\n        rest().each(fn);\n        return self;\n      },\n      map: function(fn) {\n        return Stream(fn(self.first()), function() {\n          return rest().map(fn);\n        });\n      }\n    };\n  };\n\n  emptyStream = {\n    map: function() {\n      return emptyStream;\n    },\n    each: function() {\n      return emptyStream;\n    },\n    get: function() {}\n  };\n\n  module.exports = Stream;\n\n}).call(this);\n",
      "type": "blob"
    },
    "streamatorium": {
      "path": "streamatorium",
      "content": "(function() {\n  var NULL, STDOUT, Streamatorium, T, accumulator, clock, clockExample, connector, counter, defer, each, filter, gate, gateExample, getJSON, identity, invoke, jsonExample, latch, map, pluck, soak, split, tee, toggle, tokenizer,\n    __slice = [].slice;\n\n  STDOUT = function(atom) {\n    return console.log(atom);\n  };\n\n  NULL = function(atom) {};\n\n  identity = function(output) {\n    return function(atom) {\n      return output(atom);\n    };\n  };\n\n  defer = function(output) {\n    return function(atom) {\n      return setTimeout(output, 0, atom);\n    };\n  };\n\n  each = function(output) {\n    return function(arrayOrItem) {\n      return [].concat(arrayOrItem).forEach(function(item) {\n        return output(item);\n      });\n    };\n  };\n\n  getJSON = function(output) {\n    return function(url) {\n      return $.getJSON(url).then(output);\n    };\n  };\n\n  split = function() {\n    var outputs;\n    outputs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return function(atom) {\n      return outputs.forEach(function(output) {\n        return output(atom);\n      });\n    };\n  };\n\n  tee = function(sink) {\n    return function(output) {\n      return split(sink, output);\n    };\n  };\n\n  T = tee(STDOUT);\n\n  map = function(fn) {\n    return function(output) {\n      return function(atom) {\n        return output(fn(atom));\n      };\n    };\n  };\n\n  pluck = function(name) {\n    return function(output) {\n      return function(atom) {\n        return output(atom[name]);\n      };\n    };\n  };\n\n  invoke = function() {\n    var args, name;\n    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    return function(output) {\n      return function(atom) {\n        return output(atom[name].apply(atom, args));\n      };\n    };\n  };\n\n  filter = function(fn) {\n    return function(output) {\n      return function(atom) {\n        if (fn(atom)) {\n          return output(atom);\n        }\n      };\n    };\n  };\n\n  soak = filter(function(atom) {\n    return atom != null;\n  });\n\n  toggle = function(output) {\n    var value;\n    value = true;\n    return function(atom) {\n      output(value);\n      return value = !value;\n    };\n  };\n\n  counter = function(output) {\n    var value;\n    value = 0;\n    return function(atom) {\n      return output(value += 1);\n    };\n  };\n\n  accumulator = function(output) {\n    var value;\n    value = 0;\n    return function(atom) {\n      return output(value += atom);\n    };\n  };\n\n  tokenizer = function(output) {\n    var word;\n    word = \"\";\n    return function(character) {\n      if (character.match(/\\s/)) {\n        if (word) {\n          output(word);\n          return word = \"\";\n        }\n      } else {\n        return word += character;\n      }\n    };\n  };\n\n  connector = function() {\n    var atoms, collector, flush, output;\n    atoms = [];\n    output = null;\n    flush = function() {\n      var _results;\n      if (output) {\n        _results = [];\n        while (atoms.length) {\n          _results.push(output(atoms.shift()));\n        }\n        return _results;\n      }\n    };\n    collector = function(atom) {\n      atoms.push(atom);\n      return flush();\n    };\n    collector.source = function(sink) {\n      output = sink;\n      return flush();\n    };\n    return collector;\n  };\n\n  clock = function(t) {\n    return function(output) {\n      return setInterval(function() {\n        return output(1);\n      }, t * 1000);\n    };\n  };\n\n  gate = function(ctrl) {\n    return function(output) {\n      var buffer;\n      buffer = [];\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n  latch = function(ctrl) {\n    return function(output) {\n      var value;\n      value = void 0;\n      ctrl(function() {\n        return output(value);\n      });\n      return function(atom) {\n        return value = atom;\n      };\n    };\n  };\n\n  jsonExample = function() {\n    var headers, pipeline, rows, template;\n    rows = Observable([]);\n    headers = Observable([]);\n    rows.observe(function(newRows) {\n      var firstRow;\n      if (firstRow = newRows.first()) {\n        return headers(Object.keys(firstRow));\n      }\n    });\n    template = require('./templates/table')({\n      rows: rows,\n      headers: headers\n    });\n    pipeline = T(getJSON(T(rows)));\n    pipeline(\"https://api.github.com/repositories\");\n    return $(\"body\").append(template);\n  };\n\n  clockExample = function() {\n    return clock(1)(STDOUT);\n  };\n\n  gateExample = function() {\n    return 25..times(gate(clock(0.25))(soak(defer(T(NULL)))));\n  };\n\n  module.exports = Streamatorium = {\n    each: each,\n    filter: filter,\n    getJSON: getJSON,\n    identity: identity,\n    invoke: invoke,\n    map: map,\n    pluck: pluck,\n    pollute: function() {\n      return Object.keys(Streamatorium).forEach(function(name) {\n        if (name !== \"pollute\") {\n          return global[name] = Streamatorium[name];\n        }\n      });\n    },\n    T: T,\n    tee: tee,\n    toggle: toggle\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/table": {
      "path": "templates/table",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"table\");\n    __push(__element);\n    __element = document.createElement(\"thead\");\n    __push(__element);\n    __element = document.createElement(\"tr\");\n    __push(__element);\n    __each(this.headers, function(header) {\n      __element = document.createElement(\"th\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, header);\n      __push(__element);\n      __pop();\n      return __pop();\n    });\n    __pop();\n    __pop();\n    __element = document.createElement(\"tbody\");\n    __push(__element);\n    __each(this.rows, function(row) {\n      __element = document.createElement(\"tr\");\n      __push(__element);\n      Object.keys(row).each(function(name) {\n        __element = document.createElement(\"td\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, row[name]);\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      return __pop();\n    });\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "test/stream": {
      "path": "test/stream",
      "content": "(function() {\n  require(\"../streamatorium\");\n\n}).call(this);\n",
      "type": "blob"
    },
    "notes": {
      "path": "notes",
      "content": "(function() {\n  var gate;\n\n  gate = function(ctrl) {\n    return function(output) {\n      var buffer;\n      buffer = [];\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n  gate = function(ctrl) {\n    var buffer;\n    buffer = [];\n    return function(output) {\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "util": {
      "path": "util",
      "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = {\n    executeWithContext: function(program, environment, context) {\n      var args, values;\n      args = Object.keys(environment);\n      values = args.map(function(name) {\n        return environment[name];\n      });\n      return Function.apply(null, __slice.call(args).concat([program])).apply(context, values);\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "environment_helpers": {
      "path": "environment_helpers",
      "content": "(function() {\n  if (!Object.prototype.tap) {\n    Object.defineProperty(Object.prototype, \"tap\", {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: function(fn) {\n        fn(this);\n        return this;\n      }\n    });\n  }\n\n  global.countTo = function(n) {\n    return function(output) {\n      var i, _results;\n      i = 0;\n      _results = [];\n      while (i < n) {\n        output(i);\n        _results.push(i += 1);\n      }\n      return _results;\n    };\n  };\n\n  global.prettyPrint = function(output) {\n    return function(atom) {\n      return output(JSON.stringify(atom, null, 2));\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "interactive_runtime": {
      "path": "interactive_runtime",
      "content": "(function() {\n  var executeWithContext;\n\n  require(\"/environment_helpers\");\n\n  require(\"/streamatorium\").pollute();\n\n  executeWithContext = require(\"/util\").executeWithContext;\n\n  Interactive.register(\"pipe\", function(_arg) {\n    var STDOUT, outputElement, program, runtimeElement, source;\n    source = _arg.source, runtimeElement = _arg.runtimeElement;\n    program = CoffeeScript.compile(source);\n    outputElement = document.createElement(\"pre\");\n    runtimeElement.empty().append(outputElement);\n    STDOUT = function(atom) {\n      return outputElement.textContent += \"\" + atom + \"\\n\";\n    };\n    return executeWithContext(program, {\n      T: tee(STDOUT),\n      STDOUT: STDOUT,\n      NULL: function() {}\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    }
  },
  "entryPoint": "streamatorium",
  "dependencies": {},
  "remoteDependencies": [
    "http://strd6.github.io/require/v0.2.1.js"
  ],
  "repository": {
    "id": 12873038,
    "name": "stream",
    "full_name": "STRd6/stream",
    "owner": {
      "login": "STRd6",
      "id": 18894,
      "avatar_url": "https://1.gravatar.com/avatar/33117162fff8a9cf50544a604f60c045?d=https%3A%2F%2Fidenticons.github.com%2F39df222bffe39629d904e4883eabc654.png",
      "gravatar_id": "33117162fff8a9cf50544a604f60c045",
      "url": "https://api.github.com/users/STRd6",
      "html_url": "https://github.com/STRd6",
      "followers_url": "https://api.github.com/users/STRd6/followers",
      "following_url": "https://api.github.com/users/STRd6/following{/other_user}",
      "gists_url": "https://api.github.com/users/STRd6/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/STRd6/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/STRd6/subscriptions",
      "organizations_url": "https://api.github.com/users/STRd6/orgs",
      "repos_url": "https://api.github.com/users/STRd6/repos",
      "events_url": "https://api.github.com/users/STRd6/events{/privacy}",
      "received_events_url": "https://api.github.com/users/STRd6/received_events",
      "type": "User"
    },
    "private": false,
    "html_url": "https://github.com/STRd6/stream",
    "description": "Learning about streams",
    "fork": false,
    "url": "https://api.github.com/repos/STRd6/stream",
    "forks_url": "https://api.github.com/repos/STRd6/stream/forks",
    "keys_url": "https://api.github.com/repos/STRd6/stream/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/STRd6/stream/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/STRd6/stream/teams",
    "hooks_url": "https://api.github.com/repos/STRd6/stream/hooks",
    "issue_events_url": "https://api.github.com/repos/STRd6/stream/issues/events{/number}",
    "events_url": "https://api.github.com/repos/STRd6/stream/events",
    "assignees_url": "https://api.github.com/repos/STRd6/stream/assignees{/user}",
    "branches_url": "https://api.github.com/repos/STRd6/stream/branches{/branch}",
    "tags_url": "https://api.github.com/repos/STRd6/stream/tags",
    "blobs_url": "https://api.github.com/repos/STRd6/stream/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/STRd6/stream/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/STRd6/stream/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/STRd6/stream/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/STRd6/stream/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/STRd6/stream/languages",
    "stargazers_url": "https://api.github.com/repos/STRd6/stream/stargazers",
    "contributors_url": "https://api.github.com/repos/STRd6/stream/contributors",
    "subscribers_url": "https://api.github.com/repos/STRd6/stream/subscribers",
    "subscription_url": "https://api.github.com/repos/STRd6/stream/subscription",
    "commits_url": "https://api.github.com/repos/STRd6/stream/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/STRd6/stream/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/STRd6/stream/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/STRd6/stream/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/STRd6/stream/contents/{+path}",
    "compare_url": "https://api.github.com/repos/STRd6/stream/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/STRd6/stream/merges",
    "archive_url": "https://api.github.com/repos/STRd6/stream/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/STRd6/stream/downloads",
    "issues_url": "https://api.github.com/repos/STRd6/stream/issues{/number}",
    "pulls_url": "https://api.github.com/repos/STRd6/stream/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/STRd6/stream/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/STRd6/stream/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/STRd6/stream/labels{/name}",
    "created_at": "2013-09-16T17:03:24Z",
    "updated_at": "2013-09-24T18:56:13Z",
    "pushed_at": "2013-09-24T18:56:12Z",
    "git_url": "git://github.com/STRd6/stream.git",
    "ssh_url": "git@github.com:STRd6/stream.git",
    "clone_url": "https://github.com/STRd6/stream.git",
    "svn_url": "https://github.com/STRd6/stream",
    "homepage": null,
    "size": 1880,
    "watchers_count": 0,
    "language": "CoffeeScript",
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "master_branch": "master",
    "default_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "network_count": 0,
    "branch": "master",
    "defaultBranch": "master",
    "includedModules": [
      "Bindable"
    ]
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  }
});
</script>
</body>
</html>