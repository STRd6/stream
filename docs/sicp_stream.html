<!DOCTYPE html>

<html>
<head>
  <title>sicp_stream</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="stream">Stream</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Here I will learn about streams using interactive models.</p>
<p>Construct a stream</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">Stream</span></span> = (first, <span class="function"><span class="title">rest</span></span>=-&gt;emptyStream) -&gt;
  self =
    first: -&gt;
      first
    rest: rest</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Get an element from a stream at position <code>n</code></p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">    get: (n) -&gt;
      <span class="keyword">if</span> n <span class="keyword">is</span> <span class="number">0</span>
        self.first()
      <span class="keyword">else</span>
        rest().get(n - <span class="number">1</span>)</code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Invoke a function for each item in a stream.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">    each: (fn) -&gt;
      fn(self.first())
      rest().each(fn)

      self</code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Transform a stream</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">    map: (fn) -&gt;
      Stream(
        fn(self.first()),
        -&gt; rest().map(fn)
      )</code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A distinguishable object representing the empty stream.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">emptyStream =
  map: -&gt;
    emptyStream
  each: -&gt;
    emptyStream
  get: -&gt;</code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Export</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">module.exports = Stream</code></pre>
</div>
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="notes">Notes</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Passing in the second argument as a function to be evaluated later is a little
tough on the user interface. The solution may be to provide helpers or higher
levels of abstraction so that we don&#39;t have to mess with streams directly,
just create them from various other sources like text, lists, ajax requests,
generator functions, etc. and be able to pipe them together in a signal flow
style.</p>
<p>Another thing to explore is promises/deferreds and using those as our piping
interface.</p>
<p>The primary use case in my mind is something like:</p>
<p>&gt;</p>
<blockquote>
<pre><code>+----------+                        +-----+                    +------+                   +--------+                        +------+
|FileReader| -&gt; Character Stream -&gt; |Lexer| -&gt; Token Stream -&gt; |Parser| -&gt; Node Stream -&gt; |Compiler| -&gt; Character Stream -&gt; |STDOUT|
+----------+                        +-----+                    +------+                   +--------+                        +------+
     |                                 |                          |                           |
     v                                 v                          v                           v                             +------+
     +---------------------------------+--------------------------+---------------------------+------------------------- -&gt; |STDERR|
                                                                                                                            +------+</code></pre>
</blockquote>
<p>Which could be connected something like:</p>
<blockquote>
<pre><code>errors STDERR

reader lexer parser compiler STDOUT</code></pre>
</blockquote>
<h2 id="resources">Resources</h2>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><a href="http://mitpress.mit.edu/sicp/full-text/sicp/book/node70.html">http://mitpress.mit.edu/sicp/full-text/sicp/book/node70.html</a></p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="//code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script>
<script src="http://strd6.github.io/require/v0.2.1.js"></script>
<script src="http://strd6.github.io/interactive/v0.8.0.js"></script>
<script>
  (function(pkg) {
    // Expose a require for our package so scripts can access our modules
    window.require = Require.generateFor(pkg);
  })({
  "version": "0.1.0",
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "stream\n======\n\nLearning about streams\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "entryPoint: \"streamatorium\"\nversion: \"0.1.0\"\nremoteDependencies: [\n  \"http://strd6.github.io/require/v0.2.1.js\"\n]\n",
      "type": "blob"
    },
    "sicp_stream.coffee.md": {
      "path": "sicp_stream.coffee.md",
      "mode": "100644",
      "content": "Stream\n======\n\nHere I will learn about streams using interactive models.\n\nConstruct a stream\n\n    Stream = (first, rest=->emptyStream) ->\n      self =\n        first: ->\n          first\n        rest: rest\n\nGet an element from a stream at position `n`\n\n        get: (n) ->\n          if n is 0\n            self.first()\n          else\n            rest().get(n - 1)\n\nInvoke a function for each item in a stream.\n\n        each: (fn) ->\n          fn(self.first())\n          rest().each(fn)\n\n          self\n\nTransform a stream\n\n        map: (fn) ->\n          Stream(\n            fn(self.first()),\n            -> rest().map(fn)\n          )\n\nA distinguishable object representing the empty stream.\n\n    emptyStream =\n      map: ->\n        emptyStream\n      each: ->\n        emptyStream\n      get: ->\n\nExport\n\n    module.exports = Stream\n\nNotes\n-----\n\nPassing in the second argument as a function to be evaluated later is a little\ntough on the user interface. The solution may be to provide helpers or higher\nlevels of abstraction so that we don't have to mess with streams directly,\njust create them from various other sources like text, lists, ajax requests,\ngenerator functions, etc. and be able to pipe them together in a signal flow\nstyle.\n\nAnother thing to explore is promises/deferreds and using those as our piping\ninterface.\n\nThe primary use case in my mind is something like:\n\n>\n>     +----------+                        +-----+                    +------+                   +--------+                        +------+\n>     |FileReader| -> Character Stream -> |Lexer| -> Token Stream -> |Parser| -> Node Stream -> |Compiler| -> Character Stream -> |STDOUT|\n>     +----------+                        +-----+                    +------+                   +--------+                        +------+\n>          |                                 |                          |                           |\n>          v                                 v                          v                           v                             +------+\n>          +---------------------------------+--------------------------+---------------------------+------------------------- -> |STDERR|\n>                                                                                                                                 +------+\n\nWhich could be connected something like:\n\n>     errors STDERR\n>\n>     reader lexer parser compiler STDOUT\n\nResources\n---------\n\nhttp://mitpress.mit.edu/sicp/full-text/sicp/book/node70.html\n",
      "type": "blob"
    },
    "streamatorium.coffee.md": {
      "path": "streamatorium.coffee.md",
      "mode": "100644",
      "content": "Streamatorium\n=============\n\nIntroduction\n------------\n\nThe Streamatorium is an experiment in applying functional programming and Unix\nprinciples to the web.\n\nProcesses may look something like these:\n\nPrint out even numbers to the console.\n\n>     100.times filter(even) STDOUT\n\nGet popular repos from a json data source and display them one at a time to the\nconsole.\n\n>     popular = (repo) -> repo.watchers > 100\n>\n>     json(\"https://api.github.com/repos/\") each filter(popular) STDOUT\n\n\nAtoms are any object. Atoms form streams by flowing through pipes. Atoms\noriginate in sources and end up in sinks.\n\nExample atoms:\n\n>     0, 1, \"\", true, false, \"heyyy\", 954, \n>     {}, {name: \"flambo\"}, [{...}, ...]\n\nSinks\n-----\n\nA sink is a function that accepts an atom.\n\n`STDOUT` logs any atom to the console\n\n    STDOUT = (atom) -> \n      console.log atom\n\nThe `NULL` sink eats any atom passed to it and does nothing\n\n    NULL = (atom) ->\n\nA source is a function that takes a sink as an argument.\n\n>     source = (sink) ->\n>       ...\n\nPipes\n-----\n\nA pipe is a function that takes a sink and returns a sink. A pipe is both a\nsource and a sink.\n\nA pipeline connects sources to sinks through pipes.\n\n>     source pipe0 pipe1 pipe2 sink\n\nThis works due to function composition:\n\n>     source(pipe0(pipe1(pipe2(sink))))\n\nPass items through to output unchanged. More useful as a demonstration than\nan actual pipe.\n\n    identity = (output) ->\n      (atom) ->\n        output atom\n\n>     #! pipe\n>     countTo(10) identity STDOUT\n\n----\n\nOutput atoms asynchrounously instead of immediately.\n\n    defer = (output) ->\n      (atom) ->\n        setTimeout output, 0, atom\n\n`each` splats arrays into individual items. Non-arrays are passed through as is.\n\n    each = (output) ->\n      (arrayOrItem) ->\n        [].concat(arrayOrItem).forEach (item) ->\n          output item\n\n>     #! pipe\n>     [1, 2, 3, 4, 5].tap T each STDOUT\n\n----\n\nGet JSON data from input urls then pass it along.\n\n    getJSON = (output) ->\n      (url) ->\n        $.getJSON(url).then output\n\n`split` is a generalized T. When contsructed with a list of sinks it returns\na sink that outputs to all of the sinks it was constructed with.\n\n    split = (outputs...) ->\n      (atom) ->\n        outputs.forEach (output) ->\n          output atom\n\nPipe Generators\n---------------\n\nA pipe generator is a function that returns a pipe.\n\nSimilar to unix tee, splits a stream.\n\n    tee = (sink) ->\n      (output) ->\n        split sink, output\n\nExample of `tee` implemented wthout `split`\n\n>     tee = (sink) ->     # Generator\n>       (output) ->       # Pipe\n>         (atom) ->       # Sink\n>           sink atom\n>           output atom\n\n`T` is a pipe that will mirror its atoms to the console. It is useful for\ninspecting the flow at any point in the pipeline.\n\n    T = tee(STDOUT)\n\n>     source T pipe0 T pipe1 STDOUT\n\nMaps\n----\n\nGenerate a pipe that transforms atoms by applying the given transformation\nfunction to each atom as it passes through.\n\n    map = (fn) ->\n      (output) ->\n        (atom) ->\n          output fn(atom)\n\n    characterSplitter = map (string) ->\n      string.split('')\n\nFilters\n-------\n\nGenerate a pipe that only allows certain atoms to pass through. `filter` applies\nthe given indicator function and only passes through atoms for which it returns\ntrue.\n\n    filter = (fn) ->\n      (output) ->\n        (atom) ->\n          output atom if fn(atom)\n\nThe `soak` pipe filters out `null` and `undefined` atoms.\n\n    soak = filter (atom) -> atom?\n\nStateful Pipes\n--------------\n\n`toggle` is a switch. Whenever it receives an input it will ouput either true or\nfalse and switch its state to output the opposite value the next input it\nreceives. It doesn't matter what atom it receives.\n\n    toggle = (output) ->\n      value = true\n      (atom) ->\n        output value\n        value = !value\n\nCount number of atoms that flowed through, outputting the total count each time\nand atom is received.\n\n    counter = (output) ->\n      value = 0\n      (atom) ->\n        output value += 1\n\nSum the atoms that flow through and output the current total each time an atom\nis received.\n\n    accumulator = (output) ->\n      value = 0\n      (atom) ->\n        output value += atom\n\nAggregate a stream of individual characters separated by whitespace into a stream\nof word strings.\n\n    tokenizer = (output) ->\n      word = \"\"\n\n      (character) ->\n        if character.match /\\s/\n          if word\n            output word\n\n            word = \"\"\n        else\n          word += character\n\nConnect the \"end\" of one pipeline to the begining of a new one.\n\nTODO: Explore this further, currently seems like a pain to hold a reference\nto a sink and carry it over as a source. Maybe if the constructor took names\nto refer to connectors so we could use them without carrying the instances\nourselves, ex:\n>     source pipe0 pipe1 TO(\"A\")\n>     FROM(\"A\") pipe2 pipe3 STDOUT\n\n    connector = ->\n      atoms = []\n      output = null\n\n      flush = ->\n        if output\n          while atoms.length\n            output atoms.shift()\n\n      collector = (atom) ->\n        atoms.push atom\n\n        flush()\n\n      collector.source = (sink) ->\n        output = sink\n\n        flush()\n\n      return collector\n\nClocks\n------\n\nEmit an atom periodically. The `clock` constructor returns a source.\n\n    clock = (t) ->\n      (output) ->\n        setInterval ->\n          output 1\n        , t * 1000\n\nControls\n--------\n\nTODO: Transistors and stuff.\n\nGates\n-----\n\nAttempt at a buffer that collects input and releases them based on a\ncontrol/signal input.\n\n`ctrl` is a source\n\n    gate = (ctrl) ->\n      (output) ->\n        buffer = []\n\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n\nMaintain most recent value and emit it on CTRL.\n\n    latch = (ctrl) ->\n      (output) ->\n        value = undefined\n\n        ctrl ->\n          output value\n\n        (atom) ->\n          value = atom\n\nExamples\n-------\n\nJSON to Template\n\n    jsonExample = ->\n      rows = Observable([])\n      headers = Observable([])\n\n      rows.observe (newRows) ->\n        if firstRow = newRows.first()\n          headers Object.keys firstRow\n\n      template = require('./templates/table')(\n        rows: rows\n        headers: headers\n      )\n\n      pipeline = T getJSON T rows\n      pipeline(\"https://api.github.com/repositories\")\n      $(\"body\").append(template)\n\n    clockExample = ->\n      clock(1) STDOUT\n\n    gateExample = ->\n      25.times gate(clock(0.25)) soak defer T NULL\n\n    filterExample = ->\n      even = (x) -> x % 2 is 0\n\n      100.times filter(even) STDOUT\n\n    toggleExample = ->\n      10.times toggle STDOUT\n\n    tokenizerExample = ->\n       (characterSplitter each tokenizer STDOUT)(\"a sentence of words\\n\")\n\n    tokenizerExample()\n    \n    module.exports = Streamatorium =\n      each: each\n      identity: identity\n\n      pollute: ->\n        Object.keys(Streamatorium).forEach (name) ->\n          unless name is \"pollute\"\n            global[name] = Streamatorium[name]\n\n      tee: tee\n\n      T: T\n\nLive Examples\n-------------\n\n`pipe` examples provide the pipe functions and dislpay all atoms received in\nSTDOUT on the righthand side.\n\n>     #! setup\n>     require(\"/interactive_runtime\")\n",
      "type": "blob"
    },
    "templates/table.haml.md": {
      "path": "templates/table.haml.md",
      "mode": "100644",
      "content": "A table template to render rows from stuff!\n\n    %table\n      %thead\n        %tr\n          - each @headers, (header) ->\n            %th= header\n      %tbody\n        - each @rows, (row) ->\n          %tr\n            - Object.keys(row).each (name) ->\n              %td= row[name]\n",
      "type": "blob"
    },
    "test/stream.coffee.md": {
      "path": "test/stream.coffee.md",
      "mode": "100644",
      "content": "    require \"../streamatorium\"\n",
      "type": "blob"
    },
    "notes.coffee.md": {
      "path": "notes.coffee.md",
      "mode": "100644",
      "content": "Notes\n=====\n\nWhen nesting the functions avoid leaky closures:\n\n    # GOOD, can reuse the \"same\" gate in multiple streams no problem\n    gate = (ctrl) ->\n      (output) ->\n        buffer = []\n\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n\n    # BAD, gate will get weird if used in multiple streams\n    gate = (ctrl) ->\n      buffer = []\n\n      (output) ->\n        ctrl ->\n          output buffer.shift()\n\n        (atom) ->\n          buffer.push atom\n",
      "type": "blob"
    },
    "util.coffee.md": {
      "path": "util.coffee.md",
      "mode": "100644",
      "content": "Utility Functions\n-----------------\n\n    module.exports =\n\nEvaluate a program with a given environment object.\n\nThe values of the environment are mapped to local variables with names equal to\nthe keys.\n\nThe given program is then run with that environment and optionally a context for\n`this`.\n\n      executeWithContext: (program, environment, context) ->\n        args = Object.keys(environment)\n\n        values = args.map (name) -> \n          environment[name]\n\n        Function(args..., program).apply(context, values)\n",
      "type": "blob"
    },
    "environment_helpers.coffee.md": {
      "path": "environment_helpers.coffee.md",
      "mode": "100644",
      "content": "Environment Helpers\n-------------------\n\nSome helpers that we add to the global environment so we can use our streams to\ntheir fullest.\n\nAdding `Object#tap` so it's easier to put any object into the beginnig of a\nstream.\n\n    unless Object.prototype.tap\n      Object.defineProperty Object.prototype, \"tap\",\n        enumerable: false\n        configurable: false\n        writable: false\n        value: (fn) ->\n          fn(this)\n\n          return this\n\n`countTo` generates a source that emits sequence of values from [0, n).\n\n    global.countTo = (n) ->\n      (output) ->\n        i = 0\n        while i < n\n          output(i)\n          i += 1\n",
      "type": "blob"
    },
    "interactive_runtime.coffee.md": {
      "path": "interactive_runtime.coffee.md",
      "mode": "100644",
      "content": "Interactive Runtime\n-------------------\n\nRegister our interactive documentation runtime components.\n\n    require(\"/environment_helpers\")\n    require(\"/streamatorium\").pollute()\n    {executeWithContext} = require(\"/util\")\n\n    Interactive.register \"pipe\", ({source, runtimeElement}) ->\n      program = CoffeeScript.compile(source)\n\n      outputElement = document.createElement \"pre\"\n      runtimeElement.empty().append outputElement\n\n      STDOUT = (atom) ->\n        outputElement.textContent += \"#{atom}\\n\"\n\n      executeWithContext program,\n        T: tee(STDOUT)\n        STDOUT: STDOUT\n        NULL: ->\n",
      "type": "blob"
    }
  },
  "distribution": {
    "pixie": {
      "path": "pixie",
      "content": "module.exports = {\"entryPoint\":\"streamatorium\",\"version\":\"0.1.0\",\"remoteDependencies\":[\"http://strd6.github.io/require/v0.2.1.js\"]};",
      "type": "blob"
    },
    "sicp_stream": {
      "path": "sicp_stream",
      "content": "(function() {\n  var Stream, emptyStream;\n\n  Stream = function(first, rest) {\n    var self;\n    if (rest == null) {\n      rest = function() {\n        return emptyStream;\n      };\n    }\n    return self = {\n      first: function() {\n        return first;\n      },\n      rest: rest,\n      get: function(n) {\n        if (n === 0) {\n          return self.first();\n        } else {\n          return rest().get(n - 1);\n        }\n      },\n      each: function(fn) {\n        fn(self.first());\n        rest().each(fn);\n        return self;\n      },\n      map: function(fn) {\n        return Stream(fn(self.first()), function() {\n          return rest().map(fn);\n        });\n      }\n    };\n  };\n\n  emptyStream = {\n    map: function() {\n      return emptyStream;\n    },\n    each: function() {\n      return emptyStream;\n    },\n    get: function() {}\n  };\n\n  module.exports = Stream;\n\n}).call(this);\n",
      "type": "blob"
    },
    "streamatorium": {
      "path": "streamatorium",
      "content": "(function() {\n  var NULL, STDOUT, Streamatorium, T, accumulator, characterSplitter, clock, clockExample, connector, counter, defer, each, filter, filterExample, gate, gateExample, getJSON, identity, jsonExample, latch, map, soak, split, tee, toggle, toggleExample, tokenizer, tokenizerExample,\n    __slice = [].slice;\n\n  STDOUT = function(atom) {\n    return console.log(atom);\n  };\n\n  NULL = function(atom) {};\n\n  identity = function(output) {\n    return function(atom) {\n      return output(atom);\n    };\n  };\n\n  defer = function(output) {\n    return function(atom) {\n      return setTimeout(output, 0, atom);\n    };\n  };\n\n  each = function(output) {\n    return function(arrayOrItem) {\n      return [].concat(arrayOrItem).forEach(function(item) {\n        return output(item);\n      });\n    };\n  };\n\n  getJSON = function(output) {\n    return function(url) {\n      return $.getJSON(url).then(output);\n    };\n  };\n\n  split = function() {\n    var outputs;\n    outputs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return function(atom) {\n      return outputs.forEach(function(output) {\n        return output(atom);\n      });\n    };\n  };\n\n  tee = function(sink) {\n    return function(output) {\n      return split(sink, output);\n    };\n  };\n\n  T = tee(STDOUT);\n\n  map = function(fn) {\n    return function(output) {\n      return function(atom) {\n        return output(fn(atom));\n      };\n    };\n  };\n\n  characterSplitter = map(function(string) {\n    return string.split('');\n  });\n\n  filter = function(fn) {\n    return function(output) {\n      return function(atom) {\n        if (fn(atom)) {\n          return output(atom);\n        }\n      };\n    };\n  };\n\n  soak = filter(function(atom) {\n    return atom != null;\n  });\n\n  toggle = function(output) {\n    var value;\n    value = true;\n    return function(atom) {\n      output(value);\n      return value = !value;\n    };\n  };\n\n  counter = function(output) {\n    var value;\n    value = 0;\n    return function(atom) {\n      return output(value += 1);\n    };\n  };\n\n  accumulator = function(output) {\n    var value;\n    value = 0;\n    return function(atom) {\n      return output(value += atom);\n    };\n  };\n\n  tokenizer = function(output) {\n    var word;\n    word = \"\";\n    return function(character) {\n      if (character.match(/\\s/)) {\n        if (word) {\n          output(word);\n          return word = \"\";\n        }\n      } else {\n        return word += character;\n      }\n    };\n  };\n\n  connector = function() {\n    var atoms, collector, flush, output;\n    atoms = [];\n    output = null;\n    flush = function() {\n      var _results;\n      if (output) {\n        _results = [];\n        while (atoms.length) {\n          _results.push(output(atoms.shift()));\n        }\n        return _results;\n      }\n    };\n    collector = function(atom) {\n      atoms.push(atom);\n      return flush();\n    };\n    collector.source = function(sink) {\n      output = sink;\n      return flush();\n    };\n    return collector;\n  };\n\n  clock = function(t) {\n    return function(output) {\n      return setInterval(function() {\n        return output(1);\n      }, t * 1000);\n    };\n  };\n\n  gate = function(ctrl) {\n    return function(output) {\n      var buffer;\n      buffer = [];\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n  latch = function(ctrl) {\n    return function(output) {\n      var value;\n      value = void 0;\n      ctrl(function() {\n        return output(value);\n      });\n      return function(atom) {\n        return value = atom;\n      };\n    };\n  };\n\n  jsonExample = function() {\n    var headers, pipeline, rows, template;\n    rows = Observable([]);\n    headers = Observable([]);\n    rows.observe(function(newRows) {\n      var firstRow;\n      if (firstRow = newRows.first()) {\n        return headers(Object.keys(firstRow));\n      }\n    });\n    template = require('./templates/table')({\n      rows: rows,\n      headers: headers\n    });\n    pipeline = T(getJSON(T(rows)));\n    pipeline(\"https://api.github.com/repositories\");\n    return $(\"body\").append(template);\n  };\n\n  clockExample = function() {\n    return clock(1)(STDOUT);\n  };\n\n  gateExample = function() {\n    return 25..times(gate(clock(0.25))(soak(defer(T(NULL)))));\n  };\n\n  filterExample = function() {\n    var even;\n    even = function(x) {\n      return x % 2 === 0;\n    };\n    return 100..times(filter(even)(STDOUT));\n  };\n\n  toggleExample = function() {\n    return 10..times(toggle(STDOUT));\n  };\n\n  tokenizerExample = function() {\n    return (characterSplitter(each(tokenizer(STDOUT))))(\"a sentence of words\\n\");\n  };\n\n  tokenizerExample();\n\n  module.exports = Streamatorium = {\n    each: each,\n    identity: identity,\n    pollute: function() {\n      return Object.keys(Streamatorium).forEach(function(name) {\n        if (name !== \"pollute\") {\n          return global[name] = Streamatorium[name];\n        }\n      });\n    },\n    tee: tee,\n    T: T\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/table": {
      "path": "templates/table",
      "content": "module.exports = (function(data) {\n  return (function() {\n    var __attribute, __each, __element, __filter, __on, __pop, __push, __render, __text, __with, _ref;\n    _ref = HAMLjr.Runtime(this), __push = _ref.__push, __pop = _ref.__pop, __attribute = _ref.__attribute, __filter = _ref.__filter, __text = _ref.__text, __on = _ref.__on, __each = _ref.__each, __with = _ref.__with, __render = _ref.__render;\n    __push(document.createDocumentFragment());\n    __element = document.createElement(\"table\");\n    __push(__element);\n    __element = document.createElement(\"thead\");\n    __push(__element);\n    __element = document.createElement(\"tr\");\n    __push(__element);\n    __each(this.headers, function(header) {\n      __element = document.createElement(\"th\");\n      __push(__element);\n      __element = document.createTextNode('');\n      __text(__element, header);\n      __push(__element);\n      __pop();\n      return __pop();\n    });\n    __pop();\n    __pop();\n    __element = document.createElement(\"tbody\");\n    __push(__element);\n    __each(this.rows, function(row) {\n      __element = document.createElement(\"tr\");\n      __push(__element);\n      Object.keys(row).each(function(name) {\n        __element = document.createElement(\"td\");\n        __push(__element);\n        __element = document.createTextNode('');\n        __text(__element, row[name]);\n        __push(__element);\n        __pop();\n        return __pop();\n      });\n      return __pop();\n    });\n    __pop();\n    __pop();\n    return __pop();\n  }).call(data);\n});\n;",
      "type": "blob"
    },
    "test/stream": {
      "path": "test/stream",
      "content": "(function() {\n  require(\"../streamatorium\");\n\n}).call(this);\n",
      "type": "blob"
    },
    "notes": {
      "path": "notes",
      "content": "(function() {\n  var gate;\n\n  gate = function(ctrl) {\n    return function(output) {\n      var buffer;\n      buffer = [];\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n  gate = function(ctrl) {\n    var buffer;\n    buffer = [];\n    return function(output) {\n      ctrl(function() {\n        return output(buffer.shift());\n      });\n      return function(atom) {\n        return buffer.push(atom);\n      };\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "util": {
      "path": "util",
      "content": "(function() {\n  var __slice = [].slice;\n\n  module.exports = {\n    executeWithContext: function(program, environment, context) {\n      var args, values;\n      args = Object.keys(environment);\n      values = args.map(function(name) {\n        return environment[name];\n      });\n      return Function.apply(null, __slice.call(args).concat([program])).apply(context, values);\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "environment_helpers": {
      "path": "environment_helpers",
      "content": "(function() {\n  if (!Object.prototype.tap) {\n    Object.defineProperty(Object.prototype, \"tap\", {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: function(fn) {\n        fn(this);\n        return this;\n      }\n    });\n  }\n\n  global.countTo = function(n) {\n    return function(output) {\n      var i, _results;\n      i = 0;\n      _results = [];\n      while (i < n) {\n        output(i);\n        _results.push(i += 1);\n      }\n      return _results;\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "interactive_runtime": {
      "path": "interactive_runtime",
      "content": "(function() {\n  var executeWithContext;\n\n  require(\"/environment_helpers\");\n\n  require(\"/streamatorium\").pollute();\n\n  executeWithContext = require(\"/util\").executeWithContext;\n\n  Interactive.register(\"pipe\", function(_arg) {\n    var STDOUT, outputElement, program, runtimeElement, source;\n    source = _arg.source, runtimeElement = _arg.runtimeElement;\n    program = CoffeeScript.compile(source);\n    outputElement = document.createElement(\"pre\");\n    runtimeElement.empty().append(outputElement);\n    STDOUT = function(atom) {\n      return outputElement.textContent += \"\" + atom + \"\\n\";\n    };\n    return executeWithContext(program, {\n      T: tee(STDOUT),\n      STDOUT: STDOUT,\n      NULL: function() {}\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    }
  },
  "entryPoint": "streamatorium",
  "dependencies": {},
  "remoteDependencies": [
    "http://strd6.github.io/require/v0.2.1.js"
  ],
  "repository": {
    "id": 12873038,
    "name": "stream",
    "full_name": "STRd6/stream",
    "owner": {
      "login": "STRd6",
      "id": 18894,
      "avatar_url": "https://1.gravatar.com/avatar/33117162fff8a9cf50544a604f60c045?d=https%3A%2F%2Fidenticons.github.com%2F39df222bffe39629d904e4883eabc654.png",
      "gravatar_id": "33117162fff8a9cf50544a604f60c045",
      "url": "https://api.github.com/users/STRd6",
      "html_url": "https://github.com/STRd6",
      "followers_url": "https://api.github.com/users/STRd6/followers",
      "following_url": "https://api.github.com/users/STRd6/following{/other_user}",
      "gists_url": "https://api.github.com/users/STRd6/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/STRd6/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/STRd6/subscriptions",
      "organizations_url": "https://api.github.com/users/STRd6/orgs",
      "repos_url": "https://api.github.com/users/STRd6/repos",
      "events_url": "https://api.github.com/users/STRd6/events{/privacy}",
      "received_events_url": "https://api.github.com/users/STRd6/received_events",
      "type": "User"
    },
    "private": false,
    "html_url": "https://github.com/STRd6/stream",
    "description": "Learning about streams",
    "fork": false,
    "url": "https://api.github.com/repos/STRd6/stream",
    "forks_url": "https://api.github.com/repos/STRd6/stream/forks",
    "keys_url": "https://api.github.com/repos/STRd6/stream/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/STRd6/stream/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/STRd6/stream/teams",
    "hooks_url": "https://api.github.com/repos/STRd6/stream/hooks",
    "issue_events_url": "https://api.github.com/repos/STRd6/stream/issues/events{/number}",
    "events_url": "https://api.github.com/repos/STRd6/stream/events",
    "assignees_url": "https://api.github.com/repos/STRd6/stream/assignees{/user}",
    "branches_url": "https://api.github.com/repos/STRd6/stream/branches{/branch}",
    "tags_url": "https://api.github.com/repos/STRd6/stream/tags",
    "blobs_url": "https://api.github.com/repos/STRd6/stream/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/STRd6/stream/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/STRd6/stream/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/STRd6/stream/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/STRd6/stream/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/STRd6/stream/languages",
    "stargazers_url": "https://api.github.com/repos/STRd6/stream/stargazers",
    "contributors_url": "https://api.github.com/repos/STRd6/stream/contributors",
    "subscribers_url": "https://api.github.com/repos/STRd6/stream/subscribers",
    "subscription_url": "https://api.github.com/repos/STRd6/stream/subscription",
    "commits_url": "https://api.github.com/repos/STRd6/stream/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/STRd6/stream/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/STRd6/stream/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/STRd6/stream/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/STRd6/stream/contents/{+path}",
    "compare_url": "https://api.github.com/repos/STRd6/stream/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/STRd6/stream/merges",
    "archive_url": "https://api.github.com/repos/STRd6/stream/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/STRd6/stream/downloads",
    "issues_url": "https://api.github.com/repos/STRd6/stream/issues{/number}",
    "pulls_url": "https://api.github.com/repos/STRd6/stream/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/STRd6/stream/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/STRd6/stream/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/STRd6/stream/labels{/name}",
    "created_at": "2013-09-16T17:03:24Z",
    "updated_at": "2013-09-24T18:56:13Z",
    "pushed_at": "2013-09-24T18:56:12Z",
    "git_url": "git://github.com/STRd6/stream.git",
    "ssh_url": "git@github.com:STRd6/stream.git",
    "clone_url": "https://github.com/STRd6/stream.git",
    "svn_url": "https://github.com/STRd6/stream",
    "homepage": null,
    "size": 1880,
    "watchers_count": 0,
    "language": "CoffeeScript",
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "master_branch": "master",
    "default_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "network_count": 0,
    "branch": "master",
    "defaultBranch": "master",
    "includedModules": [
      "Bindable"
    ]
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  }
});
</script>
</body>
</html>